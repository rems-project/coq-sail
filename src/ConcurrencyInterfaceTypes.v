(* Concurrency interface base types, as generated by Sail.*)
From Sail Require Import Real Base.
From stdpp Require Import base countable.
Import ListNotations.
Open Scope string.
Open Scope bool.
Open Scope Z.

Inductive Access_variety := AV_plain | AV_exclusive | AV_atomic_rmw.
Scheme Equality for Access_variety.
#[export] Instance Decidable_eq_Access_variety : EqDecision Access_variety := Access_variety_eq_dec.
#[export] Instance dummy_Access_variety : Inhabited Access_variety := { inhabitant := AV_plain }.
#[export] Instance Countable_Access_variety : Countable Access_variety. refine {|
  encode x := match x with AV_plain => 1 | AV_exclusive => 2 | AV_atomic_raw => 3 end%positive;
  decode x := match x with 1 => Some AV_plain | 2 => Some AV_exclusive | 3 => Some AV_atomic_rmw | _ => None end%positive;
|}.
destruct 0; reflexivity.
Defined.

Inductive Access_strength := AS_normal | AS_rel_or_acq | AS_acq_rcpc.
Scheme Equality for Access_strength.
#[export] Instance Decidable_eq_Access_strength : EqDecision Access_strength := Access_strength_eq_dec.
#[export] Instance dummy_Access_strength : Inhabited Access_strength := { inhabitant := AS_normal }.
#[export] Instance Countable_Access_strength : Countable Access_strength. refine {|
  encode x := match x with AS_normal => 1 | AS_rel_or_acq => 2 | AV_atomic_raw => 3 end%positive;
  decode x := match x with 1 => Some AS_normal | 2 => Some AS_rel_or_acq | 3 => Some AS_acq_rcpc | _ => None end%positive;
|}.
destruct 0; reflexivity.
Defined.


Record Explicit_access_kind :=
{
  Explicit_access_kind_variety : Access_variety;
  Explicit_access_kind_strength : Access_strength;
}.
Arguments Explicit_access_kind : clear implicits.
Notation "{[ r 'with' 'Explicit_access_kind_variety' := e ]}" :=
  match r with Build_Explicit_access_kind _ f1 => Build_Explicit_access_kind e f1 end.
Notation "{[ r 'with' 'Explicit_access_kind_strength' := e ]}" :=
  match r with Build_Explicit_access_kind f0 _ => Build_Explicit_access_kind f0 e end.
#[export] Instance Decidable_eq_Explicit_access_kind : EqDecision Explicit_access_kind.
intros [x0 x1]; intros [y0 y1].
cmp_record_field x0 y0.
cmp_record_field x1 y1.
left; subst; reflexivity.
Defined.
#[export]
Instance dummy_Explicit_access_kind :
  Inhabited (Explicit_access_kind ) :=
{
  inhabitant := {|
    Explicit_access_kind_variety := inhabitant;
    Explicit_access_kind_strength := inhabitant
|} }.
#[export] Instance Countable_Explicit_access_kind : Countable Explicit_access_kind.
refine {|
  encode x := encode (Explicit_access_kind_variety x, Explicit_access_kind_strength x);
  decode x := '(x0, x1) â† decode x; mret (Build_Explicit_access_kind x0 x1);
|}.
intros [x0 x1]; rewrite decode_encode; reflexivity.
Defined.

Inductive Access_kind {arch_ak : Type} :=
| AK_explicit : Explicit_access_kind -> Access_kind
| AK_ifetch : unit -> Access_kind
| AK_ttw : unit -> Access_kind
| AK_arch : arch_ak -> Access_kind.
Arguments Access_kind : clear implicits.
#[export]
Instance Decidable_eq_Access_kind `{EqDecision arch_ak} : EqDecision (Access_kind arch_ak).
refine (fun x y =>
  match x,y with
  | AK_explicit akx, AK_explicit aky => match decide (akx = aky) with left _ => left _ | right _ => right _ end
  | AK_ifetch tt, AK_ifetch tt => left _
  | AK_ttw tt, AK_ttw tt => left _
  | AK_arch akx, AK_arch aky => match decide (akx = aky) with left _ => left _ | right _ => right _ end
  | _, _ => right _
  end).
all: congruence.
Defined.
#[export]
Instance dummy_Access_kind {arch_ak : Type} `{Inhabited arch_ak} :
  Inhabited (Access_kind arch_ak) :=
{
  inhabitant := AK_explicit inhabitant
}.
Instance Countable_Access_kind `{Countable arch_ak} : Countable (Access_kind arch_ak).
refine {|
  encode x := encode match x with AK_explicit ak => (1, encode ak) | AK_ifetch u => (2, encode u) | AK_ttw u => (3, encode u) | AK_arch ak => (4, encode ak) end%positive;
  decode x := match decode x with Some (1, ak) => AK_explicit <$> decode ak | Some (2, u) => AK_ifetch <$> decode u | Some (3, u) => AK_ttw <$> decode u | Some (4, ak) => AK_arch <$> decode ak | _ => None end%positive
|}.
intros [x| | |x]; rewrite !decode_encode; reflexivity.
Defined.

Record Mem_read_request {n : Z} {vasize : Z} {pa : Type} {ts : Type} {arch_ak : Type} (*n >? 0*) :=
{
  Mem_read_request_access_kind : Access_kind arch_ak;
  Mem_read_request_va : option (mword vasize);
  Mem_read_request_pa : pa;
  Mem_read_request_translation : ts;
  Mem_read_request_size : Z;
  Mem_read_request_tag : bool;
}.
Arguments Mem_read_request : clear implicits.
Notation "{[ r 'with' 'Mem_read_request_access_kind' := e ]}" :=
  match r with Build_Mem_read_request _ _ _ _ _ _ f1 f2 f3 f4 f5 =>
    Build_Mem_read_request _ _ _ _ _ e f1 f2 f3 f4 f5 end.
Notation "{[ r 'with' 'Mem_read_request_va' := e ]}" :=
  match r with Build_Mem_read_request _ _ _ _ _ f0 _ f2 f3 f4 f5 =>
    Build_Mem_read_request _ _ _ _ _ f0 e f2 f3 f4 f5 end.
Notation "{[ r 'with' 'Mem_read_request_pa' := e ]}" :=
  match r with Build_Mem_read_request _ _ _ _ _ f0 f1 _ f3 f4 f5 =>
    Build_Mem_read_request _ _ _ _ _ f0 f1 e f3 f4 f5 end.
Notation "{[ r 'with' 'Mem_read_request_translation' := e ]}" :=
  match r with Build_Mem_read_request _ _ _ _ _ f0 f1 f2 _ f4 f5 =>
    Build_Mem_read_request _ _ _ _ _ f0 f1 f2 e f4 f5 end.
Notation "{[ r 'with' 'Mem_read_request_size' := e ]}" :=
  match r with Build_Mem_read_request _ _ _ _ _ f0 f1 f2 f3 _ f5 =>
    Build_Mem_read_request _ _ _ _ _ f0 f1 f2 f3 e f5 end.
Notation "{[ r 'with' 'Mem_read_request_tag' := e ]}" :=
  match r with Build_Mem_read_request _ _ _ _ _ f0 f1 f2 f3 f4 _ =>
    Build_Mem_read_request _ _ _ _ _ f0 f1 f2 f3 f4 e end.
#[export]
Instance dummy_Mem_read_request {n : Z} {vasize : Z} {pa : Type} {ts : Type} {arch_ak : Type}
  (*n >? 0*) `{Inhabited pa} `{Inhabited ts} `{Inhabited arch_ak} :
  Inhabited (Mem_read_request n vasize pa ts arch_ak) :=
{
  inhabitant := {|
    Mem_read_request_access_kind := inhabitant;
    Mem_read_request_va := inhabitant;
    Mem_read_request_pa := inhabitant;
    Mem_read_request_translation := inhabitant;
    Mem_read_request_size := inhabitant;
    Mem_read_request_tag := inhabitant
|} }.


Record Mem_write_request {n : Z} {vasize : Z} {pa : Type} {ts : Type} {arch_ak : Type} (*n >? 0*) :=
{
  Mem_write_request_access_kind : Access_kind arch_ak;
  Mem_write_request_va : option (mword vasize);
  Mem_write_request_pa : pa;
  Mem_write_request_translation : ts;
  Mem_write_request_size : Z;
  Mem_write_request_value : option (mword (8 * n));
  Mem_write_request_tag : option bool;
}.
Arguments Mem_write_request : clear implicits.
Arguments Build_Mem_write_request &.
Notation "{[ r 'with' 'Mem_write_request_access_kind' := e ]}" :=
  match r with Build_Mem_write_request _ _ _ _ _ _ f1 f2 f3 f4 f5 f6 =>
    Build_Mem_write_request _ _ _ _ _ e f1 f2 f3 f4 f5 f6 end.
Notation "{[ r 'with' 'Mem_write_request_va' := e ]}" :=
  match r with Build_Mem_write_request _ _ _ _ _ f0 _ f2 f3 f4 f5 f6 =>
    Build_Mem_write_request _ _ _ _ _ f0 e f2 f3 f4 f5 f6 end.
Notation "{[ r 'with' 'Mem_write_request_pa' := e ]}" :=
  match r with Build_Mem_write_request _ _ _ _ _ f0 f1 _ f3 f4 f5 f6 =>
    Build_Mem_write_request _ _ _ _ _ f0 f1 e f3 f4 f5 f6 end.
Notation "{[ r 'with' 'Mem_write_request_translation' := e ]}" :=
  match r with Build_Mem_write_request _ _ _ _ _ f0 f1 f2 _ f4 f5 f6 =>
    Build_Mem_write_request _ _ _ _ _ f0 f1 f2 e f4 f5 f6 end.
Notation "{[ r 'with' 'Mem_write_request_size' := e ]}" :=
  match r with Build_Mem_write_request _ _ _ _ _ f0 f1 f2 f3 _ f5 f6 =>
    Build_Mem_write_request _ _ _ _ _ f0 f1 f2 f3 e f5 f6 end.
Notation "{[ r 'with' 'Mem_write_request_value' := e ]}" :=
  match r with Build_Mem_write_request _ _ _ _ _ f0 f1 f2 f3 f4 _ f6 =>
    Build_Mem_write_request _ _ _ _ _ f0 f1 f2 f3 f4 e f6 end.
Notation "{[ r 'with' 'Mem_write_request_tag' := e ]}" :=
  match r with Build_Mem_write_request _ _ _ _ _ f0 f1 f2 f3 f4 f5 _ =>
    Build_Mem_write_request _ _ _ _ _ f0 f1 f2 f3 f4 f5 e end.
#[export]
Instance dummy_Mem_write_request {n : Z} {vasize : Z} {pa : Type} {ts : Type} {arch_ak : Type}
  (*n >? 0*) `{Inhabited pa} `{Inhabited ts} `{Inhabited arch_ak} :
  Inhabited (Mem_write_request n vasize pa ts arch_ak) :=
{
  inhabitant := {|
    Mem_write_request_access_kind := inhabitant;
    Mem_write_request_va := inhabitant;
    Mem_write_request_pa := inhabitant;
    Mem_write_request_translation := inhabitant;
    Mem_write_request_size := inhabitant;
    Mem_write_request_value := inhabitant;
    Mem_write_request_tag := inhabitant
|} }.




