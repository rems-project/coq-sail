From Coq Require Import Strings.String.
From stdpp Require Import bitvector.definitions countable pretty.

(* For choice outcomes *)
Require Import Values.
(* This is needed because sail cannot export into multiple Coq files *)
Require Import ConcurrencyInterfaceTypes.

Local Open Scope stdpp_scope.
Local Open Scope Z_scope.

Inductive empOutcome (R : Type) :=.

(** The architecture parameters that must be provided to the interface *)
Module Type Arch.

  (** The type of registers, parametrised by the type of values for that register *)
  Parameter reg : Type -> Type.

  (** We need to implement a gmap indexed by registers *)
  Parameter reg_eq : ∀ A, EqDecision (reg A).
  #[export] Existing Instance reg_eq.
  (* This would be nice, but it essentially involves inverting reg A, which doesn't seem to be
     possible in a useful way.
  Parameter reg_countable : ∀ A, Countable (reg A).
  #[export] Existing Instance reg_countable.
  *)

  Inductive greg := GReg (A : Type) (r : reg A).
  #[global] Arguments GReg [_] _.
  #[global] Coercion GReg : reg >-> greg.

  Parameter greg_eq : EqDecision greg.
  #[export] Existing Instance greg_eq.

  Parameter greg_cnt : Countable greg.
  #[export] Existing Instance greg_cnt.

  Parameter greg_pretty : Pretty greg.
  #[export] Existing Instance greg_pretty.

  #[export] Hint Extern 1 (reg _) => assumption : typeclass_instances.
  Parameter regval_inhabited : ∀ A, reg A → Inhabited A.
  #[export] Existing Instance regval_inhabited.
  Parameter regval_eq : ∀ A, reg A → EqDecision A.
  #[export] Existing Instance regval_eq.
  Parameter regval_cnt : ∀ A (r : reg A), Countable A.
  #[export] Existing Instance regval_cnt.

  (** From a register equality proof, we need to transport a register value.
      This must compute (with vm_compute) even if the proof is opaque, For Ocaml
      extraction, this should be extracted to Obj.magic *)
  Parameter regval_transport:
    ∀ {A B} {rA : reg A} {rB : reg B}, rA =@{greg} rB → A → B.

  (** Soundness proof for [regval_extract] *)
  Parameter regval_transport_sound:
    ∀ A (r r' : reg A) (e : r =@{greg} r') a,
    regval_transport e a = a.

  (* Physical addresses, represented by a bitvector of a given size
     and some notion of address space.  When address spaces aren't required,
     the unit type can be used. *)
  Parameter addr_size : N.
  Parameter addr_space : Type.
  Parameter addr_space_eq : EqDecision addr_space.
  #[export] Existing Instance addr_space_eq.
  Parameter addr_space_countable : @Countable addr_space addr_space_eq.
  #[export] Existing Instance addr_space_countable.

  (** Capability support and size *)
  Parameter CHERI : bool.
  Parameter cap_size_log : N.

  (** Memory access type and classifiers *)
  Parameter mem_acc : Type.
  Parameter mem_acc_eq : EqDecision mem_acc.
  #[export] Existing Instance mem_acc_eq.
  Parameter mem_acc_countable : @Countable mem_acc mem_acc_eq.
  #[export] Existing Instance mem_acc_countable.

  Parameter mem_acc_is_explicit : mem_acc -> bool.
  Parameter mem_acc_is_ifetch : mem_acc -> bool.
  Parameter mem_acc_is_ttw : mem_acc -> bool.
  Parameter mem_acc_is_relaxed : mem_acc -> bool.
  Parameter mem_acc_is_rel_acq_rcpc : mem_acc -> bool.
  Parameter mem_acc_is_rel_acq_rcsc : mem_acc -> bool.
  Parameter mem_acc_is_standalone : mem_acc -> bool.
  Parameter mem_acc_is_exclusive : mem_acc -> bool.
  Parameter mem_acc_is_atomic_rmw : mem_acc -> bool.

  (** Translation start / end *)
  Parameter trans_start : Type.
  Parameter trans_start_eq : EqDecision trans_start.
  #[export] Existing Instance trans_start_eq.
  Parameter trans_end : Type.
  Parameter trans_end_eq : EqDecision trans_end.
  #[export] Existing Instance trans_end_eq.

  (** Abort description. This represent physical memory aborts on memory
      accesses, for example when trying to access outside of physical memory
      range. Those aborts are generated by the model*)
  Parameter abort : Type.
  Parameter abort_eq : EqDecision abort.
  #[export] Existing Instance abort_eq.

  (** Barrier types *)
  Parameter barrier : Type.
  Parameter barrier_eq : EqDecision barrier.
  #[export] Existing Instance barrier_eq.

  (** Cache operations (data and instruction caches) *)
  Parameter cache_op : Type.
  Parameter cache_op_eq : EqDecision cache_op.
  #[export] Existing Instance cache_op_eq.

  (** TLB operations *)
  Parameter tlbi : Type.
  Parameter tlbi_eq : EqDecision tlbi.
  #[export] Existing Instance tlbi_eq.

  (** Fault type for a fault raised by the instruction (not by the concurrency model)
      In Arm terms, this means any synchronous exception decided by the ISA model *)
  Parameter exn : Type.
  Parameter exn_eq : EqDecision exn.
  #[export] Existing Instance exn_eq.

  (** Identifier type for direct accesses to system registers *)
  Parameter sys_reg_id : Type.
  Parameter sys_reg_id_eq : EqDecision sys_reg_id.
  #[export] Existing Instance sys_reg_id_eq.
  Parameter sys_reg_id_countable : Countable sys_reg_id.
  #[export] Existing Instance sys_reg_id_countable.
End Arch.

Module Interface (A : Arch).
  Import A.

  Definition address := bv addr_size.
  #[export] Typeclasses Transparent address.
  #[export] Hint Transparent address : bv_unfold_db.

  Module MemReq.
    Record t :=
      make
        { access_kind : mem_acc;
          address : address;
          address_space : addr_space;
          size : N;
          num_tag : N;
        }.

    Arguments t : clear implicits.
  End MemReq.

  Section T.
    Context {eOutcome : Type -> Type}.

  Inductive outcome : Type -> Type :=
    (** The access_kind says whether this is an explicit system register
        access, and if so what system register identifier was used. *)
  | RegRead {T : Type} (reg : reg T) (access_kind : option sys_reg_id) : outcome T

    (** The access_kind says whether this is an explicit system register
        access, and if so what system register identifier was used.

        The dep_on would be the dependency of the register write.

        Generally, writing the PC introduces no dependency because control
        dependencies are specified by the branch announce *)
  | RegWrite {T : Type} (reg : reg T) (access_kind : option sys_reg_id)
             (regval: T) : outcome unit
  | MemRead (mr : MemReq.t) : outcome (bv (8 * mr.(MemReq.size)) * bv mr.(MemReq.num_tag) + abort)
  | MemWrite (mr : MemReq.t) (value : bv (8 * mr.(MemReq.size))) (tags : bv mr.(MemReq.num_tag)) : outcome (option bool + abort)
  | MemAddressAnnounce (mr : MemReq.t) : outcome unit
    (** Declare the opcode of the current instruction when known. Used for
        dependency computation *)
  | InstrAnnounce (opcode : bvn) : outcome unit
    (** The deps here specify the control dependency *)
  | BranchAnnounce sz (pa : mword sz) : outcome unit
  | Barrier : barrier -> outcome unit
  | CacheOp : cache_op -> outcome unit
  | TlbOp : tlbi -> outcome unit
  | TakeException : exn -> outcome unit
  | ReturnException : outcome unit
  | TranslationStart : trans_start -> outcome unit
  | TranslationEnd : trans_end -> outcome unit

  (** Custom outcome to support simplified models on either side that want
      symbolic outcomes. This can be use to represent abstracted sail function
      for example the Arm translation function *)
  | ExtraOutcome {A} : eOutcome A -> outcome A

  (** Bail out when something went wrong; this may be refined in the future.
      This is an ISA model triggered failure *)
  | GenericFail (msg : string) : outcome False

  | CycleCount : outcome unit
  | GetCycleCount : outcome Z

  (** The next two outcomes are for handling non-determinism. Choose will branch
      the possible executions non-deterministically for every value of the
      type given by the code *)
  | Choose ty : outcome (choose_type ty)
  (** Discard means that the instruction could never have made the previous
      non-deterministic choices and the current execution can be silently
      discarded. *)
  | Discard : outcome False

  (** Messages from the model for tracing or debugging *)
  | Message : string -> outcome unit.


  (********** Monad instance **********)

  (** This is a naive but inefficient implementation of the instruction monad.
      It might be replaced by an more efficient version later. *)
  (* TODO: Do something like itrees to take the full outcome type as a
     parameter *)
  Inductive iMon {A : Type} :=
  | Ret : A -> iMon
  | Next {T : Type} : outcome T -> (T -> iMon) -> iMon.
  Arguments iMon : clear implicits.

  Global Instance iMon_mret_inst : MRet iMon := { mret a := Ret }.

  Fixpoint iMon_bind {a b : Type} (ma : iMon a) (f : a -> iMon b) :=
    match ma with
    | Ret x => f x
    | Next oc k => Next oc (fun x => iMon_bind (k x) f) end.
  Global Instance iMon_mbind_inst : MBind iMon :=
    { mbind _ _ f x := iMon_bind x f}.

  Fixpoint iMon_fmap {a b : Type} (ma : iMon a) (f : a -> b) :=
    match ma with
    | Ret x => Ret (f x)
    | Next oc k => Next oc (fun x => iMon_fmap (k x) f)
    end.
  Global Instance iMon_fmap_inst : FMap iMon :=
    { fmap _ _  f x := iMon_fmap x f}.






  (********** Instruction semantics and traces **********)

  (** The semantics of an complete instruction. A full definition of instruction
      semantics is allowed to have an internal state that gets passed from one
      instruction to the next. This is useful to handle pre-computed instruction
      semantics (e.g. Isla). For complete instruction semantics, we expect that
      A will be unit.*)
  Record iSem :=
    {
      (** The instruction model internal state *)
      isa_state : Type;
      (** The instruction model initial state for a thread with a specific Tid
          *)
      init_state : nat -> isa_state;
      semantic : isa_state -> iMon isa_state
    }.

  (** A single event in an instruction execution. As implied by the definition
      events cannot contain termination outcome (outcomes of type
      `outcome False`) *)
  Inductive iEvent :=
  | IEvent {T : Type} : outcome T -> T -> iEvent.

  (** An execution trace for a single instruction.
      If the result is an A, it means a successful execution that returned A
      If the result is a string, it means a GenericFail *)
  Definition iTrace (A : Type) : Type := list iEvent * (A + string).

  (** A trace is pure if it only contains external events. That means it must not
      contain control-flow event. The name "pure" is WIP.*)
  Fixpoint pure_iTrace_aux (tr : list iEvent) : Prop :=
    match tr with
    | (IEvent (Choose _) _) :: _ => False
    | _ :: t => pure_iTrace_aux t
    | [] => True
    end.
  Definition pure_iTrace {A : Type} (tr : iTrace A) :=
    let '(t,r) := tr in pure_iTrace_aux t.

  (** Definition of a trace semantics matching a trace. A trace is allowed to
      omit control-flow outcomes such as Choose and still be considered
      matching. *)
  Inductive iTrace_match {A : Type} : iMon A -> iTrace A -> Prop :=
  | TMNext T (oc : outcome T) (f : T -> iMon A) (obj : T) tl res :
    iTrace_match (f obj) (tl, res) ->
    iTrace_match (Next oc f) ((IEvent oc obj) :: tl, res)
  | TMChoose ty f (v : choose_type ty) tr :
    iTrace_match (f v) tr -> iTrace_match (Next (Choose ty) f) tr
  | TMSuccess a : iTrace_match (Ret a) ([], inl a)
  | TMFailure f s : iTrace_match (Next (GenericFail s) f) ([], inr s).

  (** Semantic equivalence for instructions *)
  Definition iMon_equiv `{Equiv A} (i1 i2 : iMon A) : Prop :=
    forall trace : iTrace A,
    pure_iTrace trace -> (iTrace_match i1 trace <-> iTrace_match i2 trace).

  End T.
  Arguments outcome : clear implicits.
  Arguments iMon : clear implicits.
  Arguments iSem : clear implicits.
  Arguments iTrace : clear implicits.
  Arguments iEvent : clear implicits.

  Definition iMonExtraMap (out1 out2 : Type -> Type)
    := forall (A : Type), out1 A -> iMon out2 A.

  (** Suppose we can simulate the outcome of out1 in the instruction monad with
      architecture outcomes out2. Then  *)
  Fixpoint map_extra_iMon {out1 out2 : Type -> Type} {B : Type}
    (f : iMonExtraMap out1 out2) (mon : iMon out1 B) : iMon out2 B :=
    match mon in iMon _ _ return iMon out2 _ with
    | Ret b => Ret b
    | Next oc k0 =>
        let k := fun x => map_extra_iMon f (k0 x) in
        match oc in outcome _ T
              return (T -> iMon out2 B) -> iMon out2 B with
        | RegRead reg direct => Next (RegRead reg direct)
        | RegWrite reg direct val =>
            Next (RegWrite reg direct val)
        | MemRead mr => Next (MemRead mr)
        | MemWrite mr value tags => Next (MemWrite mr value tags)
        | MemAddressAnnounce mr => Next (MemAddressAnnounce mr)
        | InstrAnnounce opcode => Next (InstrAnnounce opcode)
        | BranchAnnounce sz pa => Next (BranchAnnounce sz pa)
        | Barrier barrier => Next (Barrier barrier)
        | CacheOp cache_op => Next (CacheOp cache_op)
        | TlbOp tlb_op => Next (TlbOp tlb_op)
        | TakeException fault => Next (TakeException fault)
        | ReturnException => Next ReturnException
        | TranslationStart ts => Next (TranslationStart ts)
        | TranslationEnd te => Next (TranslationEnd te)
        | ExtraOutcome aout => iMon_bind (f _ aout)
        | GenericFail msg => Next (GenericFail msg)
        | CycleCount => Next CycleCount
        | GetCycleCount => Next GetCycleCount
        | Choose n => Next (Choose n)
        | Discard => Next (Discard)
        | Message msg => Next (Message msg)
        end k
    end.

End Interface.

Module Type InterfaceT (A : Arch).
  Include Interface A.
End InterfaceT.

Module Type InterfaceWithArch.
  Declare Module Arch : Arch.
  Include Arch.
  Include Interface Arch.
End InterfaceWithArch.
