(* Concurrency interface base types, as generated by Sail.

   These are the types found in sail/lib/concurrency_interface/read_write_v2.sail.
*)
Require Import Real Base.
From stdpp Require Import base countable.
Import ListNotations.
Open Scope string.
Open Scope bool.
Open Scope Z.

Record Mem_request {n : Z} {nt : Z} {addr_size : Z} {addr_space : Type} {mem_acc : Type}
(*(n >=? 0) && ((nt >=? 0) && (addr_size >? 0))*) := {
  Mem_request_access_kind : mem_acc;
  Mem_request_address : mword addr_size;
  Mem_request_address_space : addr_space;
  Mem_request_size : Z;
  Mem_request_num_tag : Z;
}.
Arguments Mem_request : clear implicits.
#[export]
Instance Decidable_eq_Mem_request {n : Z} {nt : Z} {addr_size : Z} {addr_space : Type}
  {mem_acc : Type} (*(n >=? 0) && ((nt >=? 0) && (addr_size >? 0))*) `{EqDecision addr_space}
  `{EqDecision mem_acc} : EqDecision (Mem_request n nt addr_size addr_space mem_acc).
   intros [x0 x1 x2 x3 x4].
   intros [y0 y1 y2 y3 y4].
  cmp_record_field x0 y0.
  cmp_record_field x1 y1.
  cmp_record_field x2 y2.
  cmp_record_field x3 y3.
  cmp_record_field x4 y4.
left; subst; reflexivity.
Defined.
#[export]
Instance Countable_Mem_request {n : Z} {nt : Z} {addr_size : Z} {addr_space : Type}
  {mem_acc : Type} (*(n >=? 0) && ((nt >=? 0) && (addr_size >? 0))*) `{Countable addr_space}
  `{Countable mem_acc} : Countable (Mem_request n nt addr_size addr_space mem_acc).
refine {|
  encode x := encode (Mem_request_access_kind x, Mem_request_address x, Mem_request_address_space x, Mem_request_size x, Mem_request_num_tag x);
  decode x := '(x0, x1, x2, x3, x4) ← decode x;
              mret (Build_Mem_request n nt addr_size addr_space mem_acc x0 x1 x2 x3 x4)
|}.
abstract (
  intros [x0 x1 x2 x3 x4];
  rewrite decode_encode;
  reflexivity).
Defined.
Notation "{[ r 'with' 'Mem_request_access_kind' := e ]}" :=
  match r with Build_Mem_request _ _ _ _ _ _ (_ as f1) (_ as f2) (_ as f3) (_ as f4) =>
    Build_Mem_request _ _ _ _ _ e f1 f2 f3 f4 end (at level 1).
Notation "{[ r 'with' 'Mem_request_address' := e ]}" :=
  match r with Build_Mem_request _ _ _ _ _ (_ as f0) _ (_ as f2) (_ as f3) (_ as f4) =>
    Build_Mem_request _ _ _ _ _ f0 e f2 f3 f4 end (at level 1).
Notation "{[ r 'with' 'Mem_request_address_space' := e ]}" :=
  match r with Build_Mem_request _ _ _ _ _ (_ as f0) (_ as f1) _ (_ as f3) (_ as f4) =>
    Build_Mem_request _ _ _ _ _ f0 f1 e f3 f4 end (at level 1).
Notation "{[ r 'with' 'Mem_request_size' := e ]}" :=
  match r with Build_Mem_request _ _ _ _ _ (_ as f0) (_ as f1) (_ as f2) _ (_ as f4) =>
    Build_Mem_request _ _ _ _ _ f0 f1 f2 e f4 end (at level 1).
Notation "{[ r 'with' 'Mem_request_num_tag' := e ]}" :=
  match r with Build_Mem_request _ _ _ _ _ (_ as f0) (_ as f1) (_ as f2) (_ as f3) _ =>
    Build_Mem_request _ _ _ _ _ f0 f1 f2 f3 e end (at level 1).
#[export]
Instance dummy_Mem_request {n : Z} {nt : Z} {addr_size : Z} {addr_space : Type}
  {mem_acc : Type} (*(n >=? 0) && ((nt >=? 0) && (addr_size >? 0))*) `{Inhabited addr_space}
  `{Inhabited mem_acc} : Inhabited (Mem_request n nt addr_size addr_space mem_acc) := {
  inhabitant := {|
    Mem_request_access_kind := inhabitant;
    Mem_request_address := inhabitant;
    Mem_request_address_space := inhabitant;
    Mem_request_size := inhabitant;
    Mem_request_num_tag := inhabitant
|} }.

